import React, {useRef, useEffect} from 'react';

const Canvas = props => {
    
    const canvasRef = useRef(null)

    let runOnce = true; // initial fields are set, after this is set to false, values will change via input from users
    let index = 0; // index for current command being executed
    let time = 0; // duration of each action executed

    let x = 100 // inital x position of the rocket
    let y = 700 // initial y position of the rocket
    let speed; // moving speed of the rocket, for some reason we cannot just pass props.fields.speed directly

    useEffect(() => {

        // getting the canvas
        const canvas = canvasRef.current
        const ctx = canvas.getContext('2d')

        const Logic = (timestamp) => {
            if (runOnce) speed = props.fields.speed

            // branch off to do whatever from here, read instructions generated by blockly 
            // (e.g. turnRight, so call method update with turnRight if statement branch executed, etc...)

            runOnce = false; // do not change initial speed again after running once
            setTimeout(()=> {
                // if there is an action, begin executing
                if (index != props.fields.commands.length) update();
                // draw everything the action has specified
                draw();
                window.requestAnimationFrame(Logic)
                // each action runs for a second, once reached, reset and go to next action
                if (time == 1000) {
                    console.log("Next Action: #" + (index+1))
                    index++;
                    time = 0;
                }
                else if (props.fields.ready) {
                    time += 10;
                }
            },10)
        }
        
        function update() {
            // if no more commands
            if (index >= props.fields.commands.length) {
                props.fields.ready = false; // turn off simulation
                return;
            }
            // if player wants to simulate their commands, and list of commands is not empty, do what they say
            if (!props.fields.ready && props.fields.commands.length > 0) return;

            if (props.fields.commands[index].type == "launch") {
                y -= speed;
                console.log("Going at speed: " + speed)
            }
            else if (props.fields.commands[index].type == "speed") {
                var child = props.fields.commands[index];
                // get the value inputted by user
                var userInput = child.childBlocks_[0].inputList[0].fieldRow[0].value_;
                speed = userInput;
                // despite setting speed, the rocket will now travel by new speed
                y -= speed;
                console.log('Now set to speed: ' + speed)
            }

            else if (props.fields.commands[index].type == "right") {
                var child = props.fields.commands[index];
                // get the value inputted by user
                var userInput = child.childBlocks_[0].inputList[0].fieldRow[0].value_;
                x += userInput;
                y -= speed;
                console.log('Moving right at: ' + speed)
            }

            else if (props.fields.commands[index].type == "left") {
                var child = props.fields.commands[index];
                // get the value inputted by user
                var userInput = child.childBlocks_[0].inputList[0].fieldRow[0].value_;
                x -= userInput;
                console.log('Moving left at: ' + speed)
            }
        }
        
        function draw() {
            ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);

            // draw the ground
            ctx.fillStyle = 'brown';
            ctx.fillRect(0, 750, ctx.canvas.width, ctx.canvas.height);
            
            // draw the rocket
            ctx.fillStyle = '#ff8080';
            // ctx.save()
            // ctx.translate(x+30/2,y+50/2)
            // ctx.rotate(45*Math.PI/180)
            // ctx.translate(-(x+30/2),-(y+50/2))
            ctx.fillRect(x, y, 30, 50);
            // ctx.restore()

            // mark the destination spot
            ctx.fillStyle = "blue";
            ctx.fillRect(800, 750, 100, 100);
            

            if (y < 0 || y > ctx.canvas.height || x < 0 || x > ctx.canvas.width) {
                window.alert('Rocket out of bounds!');
                x = 0;
                y = 0; // replace this with a reset mechanism
                props.fields.ready = false; // stop simulation
            }
        }

        // get the logics to be drawn on the canvas
        Logic();

        // setting the canvas size
        const {width, height} = canvas.getBoundingClientRect();
        if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
        }
    }, [])

    return <canvas ref={canvasRef} style={{width: 915, height: 975, backgroundColor: `grey`}} {...props}/>
}


export default Canvas;