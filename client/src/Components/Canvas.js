import React, {useRef, useEffect} from 'react';

const Canvas = props => {
    
    const canvasRef = useRef(null)

    useEffect(() => {

        // getting the canvas
        const canvas = canvasRef.current
        const ctx = canvas.getContext('2d')

        let x = 100 // inital x position of the rocket
        let y = 700 // initial y position of the rocket
        let speed; // moving speed of the rocket, for some reason we cannot just pass props.fields.speed directly

        const Logic = (timestamp) => {
            speed = props.fields.speed
            // branch off to do whatever from here, read file generated by blockly (e.g. turnRight, so call method update with turnRight if statement run, etc...)
            update();
            draw();
            window.requestAnimationFrame(Logic)
        }
        
        function update(secondsPassed) {
            // get x and y positions via props.fields.xChange & yChange respectively
            // console.log(props.fields.commands)
            
            // if player wants to simulate their commands, and list of commands is not empty, do what they say
            if (!props.fields.ready && props.fields.commands.length > 0) return;
            for (let i=0; i<props.fields.commands.length; i++) {
                if (props.fields.commands[i] == "launch") {
                    y -= speed;
                }
                else if (props.fields.commands[i] == "speed") {
                    var child = props.fields.commands[i];
                    // cannot get child due to only have the type, may have to change to contain block instead
                    console.log(child)
                }
            }
        }
        
        function draw() {
            ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);

            // draw the ground
            ctx.fillStyle= 'brown';
            ctx.fillRect(0, 750, ctx.canvas.width, ctx.canvas.height);
            
            // draw the rocket
            ctx.fillStyle = '#ff8080';
            ctx.fillRect(x, y, 30, 50);
        }

        // get the logics to be drawn on the canvas
        Logic();

        // setting the canvas size
        const {width, height} = canvas.getBoundingClientRect();
        if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
        }
    }, [])

    return <canvas ref={canvasRef} style={{width: 915, height: 975, backgroundColor: `grey`}} {...props}/>
}


export default Canvas;