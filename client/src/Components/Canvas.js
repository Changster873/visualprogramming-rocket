import React, {useRef, useEffect} from 'react';

const Canvas = props => {
    
    const canvasRef = useRef(null)

    // to run the blocks
    let index = 0; // index for current command being executed
    let time = 0; // duration of each action executed
    let angleChange = -1000; // used to help angle turn slowly to user inpput value in the useEffect cycle without using useRef hook

    // properties of the rocket
    let x = 100 // inital x position of the rocket
    let y = 700 // initial y position of the rocket
    let yspeed = 1; // moving y speed of the rocket
    let xspeed = 1; // moving x speed of the rocket
    let fuel = 100; // fuel of the rocket
    let wind = 0; // wind of this level
    let angle = 0; // angle of the rocket, 0 is upwards

    useEffect(() => {

        // getting the canvas
        const canvas = canvasRef.current
        const ctx = canvas.getContext('2d')

        const Logic = () => {
            // branch off to do whatever from here, read instructions generated by blockly 
            // (e.g. turnRight, so call method update with turnRight if statement branch executed, etc...)

            setTimeout(()=> {
                // if there is an action, begin executing
                if (index !== props.fields.commands.length) update();
                // draw everything the action has specified
                draw();
                window.requestAnimationFrame(Logic)
                // each action runs for three seconds, once reached, reset and go to next action
                //if (props.fields.ready) console.log(time + ":" +props.fields.commands[index])
                if (time === 200) {
                    time = 0;
                    index++;
                }
                else if (props.fields.ready) {
                    time++;
                }
                
            },10)
        }

        function fuelCost() {
            fuel -= (yspeed + xspeed) * 0.008;
        }

        function resetRocket(msg) {
            ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
            index = 0;
            time = 0;
            x = 100;
            y = 700;
            angle = 0;
            fuel = 100;
            xspeed = yspeed = 1;
            window.alert(msg);
        }

        function checkVictory() {
            let touchGround = false;
            if (x >= 500 && x <= 600 && y >= 650) {
                if (y < 700) y++;
                if (y >= 700) {
                    y = 700;
                    touchGround = true;
                }
            }

            if (touchGround) {
                resetRocket('Stage Complete!!!');
                props.fields.ready = false; // stop simulation
                return true;
            }
        }

        function checkBoundaries() {
            if (y >= 700) {
                resetRocket('Your rocket crashed, try again...');
                props.fields.ready = false; // stop simulation
            }
            if (y < 0 || y > ctx.canvas.height || x < 0 || x > ctx.canvas.width) {
                resetRocket('Rocket out of bounds! Resetting...');
                props.fields.ready = false; // stop simulation
            }
        }
        
        function update() {
            // if no more commands
            if (index >= props.fields.commands.length) {
                props.fields.ready = false; // turn off simulation
                // if simulation no longer running, reset graphics and states
                if (!props.fields.ready) {
                    resetRocket('Did not reach destination, resetting...');
                }
                return;
            }
            // if player wants to simulate their commands, and list of commands is not empty, do what they say
            if (!props.fields.ready && props.fields.commands.length > 0) return;

            if (props.fields.commands[index].type === "launch") {
                y -= yspeed;
                // cut fuel for this action
                fuelCost();
                console.log('Launching rocket...')
            }

            else if (props.fields.commands[index].type === "descend") {
                y += yspeed;
                // cut fuel for this action
                fuelCost();
                console.log("Descending rocket...")
            }
            else if (props.fields.commands[index].type === "yspeed") {
                let userInput;
                for (let i=0; i<props.fields.commands.length; i++){
                    if (props.fields.commands[index].childBlocks_[i].type === 'math_number') {
                        // get the value inputted by user
                        userInput = props.fields.commands[index].childBlocks_[i].inputList[0].fieldRow[0].value_;
                        break;
                    }
                }
                yspeed = userInput;
                time = 200 // setting speed, should not have the game waiting for it to complete its action
                console.log('Now set to y speed: ' + yspeed)
            }

            else if (props.fields.commands[index].type === "xspeed") {
                let userInput;
                for (let i=0; i<props.fields.commands.length; i++){
                    if (props.fields.commands[index].childBlocks_[i].type === 'math_number') {
                        // get the value inputted by user
                        userInput = props.fields.commands[index].childBlocks_[i].inputList[0].fieldRow[0].value_;
                        break;
                    }
                }
                xspeed = userInput;
                time = 200 // setting speed, should not have the game waiting for it to complete its action
                console.log('Now set to x speed: ' + xspeed)
            }

            else if (props.fields.commands[index].type === "stall") {
                // if rocket is going right
                if (angle > 0 && angle < 25) {
                    x += 1;
                    y -= yspeed;
                }
                else if (angle >= 25 && angle <= 90) {
                    x += xspeed;
                    if (angle !== 90) {
                        y -= 1;
                    }
                }
                else if (angle > 90 && angle < 120) {
                    x += xspeed;
                    y += 1;
                }
                else if (angle >= 120 && angle < 180) {
                    x += 1;
                    y += yspeed;
                }

                // if rocket is going left
                if (angle < 0 && angle > -25) {
                    x -= 1;
                    y -= yspeed;
                }
                else if (angle <= -25 && angle >= -90) {
                    x -= xspeed;
                    if (angle !== -90) {
                        y -= 1;
                    }
                }
                else if (angle < -90 && angle > -120) {
                    x -= xspeed;
                    y += 1;
                }
                else if (angle < -120 && angle > 180) {
                    x -= 1;
                    y += yspeed;
                }

                // cut fuel of this action
                fuelCost();

                console.log('Going in the same direction for this turn')
            }

            else if (props.fields.commands[index].type === "right") {
                let userInput;
                for (let i=0; i<props.fields.commands.length; i++){
                    if (props.fields.commands[index].childBlocks_[i].type === 'math_number') {
                        // get the value inputted by user
                        userInput = props.fields.commands[index].childBlocks_[i].inputList[0].fieldRow[0].value_;
                        break;
                    }
                }
                let newA = userInput + angle;
                if (angleChange === -1000) {
                    angleChange = newA;
                }
                newA = angleChange;
                if (angle !== angleChange) {
                    angle++;
                }
                else if (angle === angleChange) {
                    angleChange = -1000;
                    time = 200;
                }
                
                // cut fuel for this action
                fuelCost();
                console.log('Turning right');
            }

            else if (props.fields.commands[index].type === "left") {
                let userInput;
                for (let i=0; i<props.fields.commands.length; i++){
                    if (props.fields.commands[index].childBlocks_.length === 0) {
                        continue;
                    }
                    if (props.fields.commands[index].childBlocks_[i].type === 'math_number') {
                        // get the value inputted by user
                        userInput = props.fields.commands[index].childBlocks_[i].inputList[0].fieldRow[0].value_;
                        break;
                    }
                }
                let newA = (-1 * (userInput)) + angle;
                if (angleChange === -1000) {
                    angleChange = newA;
                }
                newA = angleChange;
                if (angle !== angleChange) {
                    angle--;
                }
                else if (angle === angleChange) {
                    angleChange = -1000;
                    time = 200;
                } 
                
                // cut fuel for this action
                fuelCost();
                console.log('Turning left')
            }
        }
        
        function draw() {
            // clear the canvas before drawing new frame
            ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);

            // have the rocket status displayed
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText('Angle: ' + angle, 10, 25);

            ctx.fillText('X Speed: ' + xspeed, 10 , 55)
            ctx.fillText('Y Speed: ' + yspeed, 10 , 85)

            ctx.fillRect(237, 5, 100, 25)
            ctx.fillText('Fuel: ' + Math.round(fuel), 150, 25);
            if (fuel >= 0 && fuel < 35) {
                ctx.fillStyle = 'red'
            }
            else if (fuel >= 35 && fuel < 65) {
                ctx.fillStyle = 'yellow'
            }
            else if (fuel >= 65 && fuel < 85) {
                ctx.fillStyle = 'orange'
            }
            else {
                ctx.fillStyle = 'green'
            }
            ctx.fillRect(237, 5, fuel, 25);

            // have the level conditions displayed
            ctx.fillStyle = 'white'
            ctx.fillText('Wind: ' + wind, 820, 25);
            
            // draw the ground
            let img2 = document.getElementById('grass')
            let img3 = document.getElementById('ground')
            for (let i=0;i<915; i+=10) {
                ctx.drawImage(img2, i, 745, 20, 20)
                for (let j=765; j<955; j+=10) {
                    ctx.drawImage(img3, i, j, 20, 20)
                }
            }
            
            // draw the rocket
            ctx.fillStyle = '#ff8080';
            ctx.save()
            ctx.translate(x+30/2,y+50/2)
            ctx.rotate(angle*Math.PI/180)
            ctx.translate(-(x+30/2),-(y+50/2))
            let img = document.getElementById('rocket')
            ctx.drawImage(img, x, y,30,50)

            // draw the rocket's engine flames
            if (props.fields.ready) {
                for (let i=0; i<20; i+=1) {
                    ctx.fillStyle = 'red'
                    ctx.fillRect(x+3+i, y+50+(Math.random()*15+1), 5, 5)
                    ctx.clearRect(x+3+i, y+50+(Math.random()*15+1), 5, 5)
                }
                for (let i=0; i<10; i+=1) {
                    ctx.fillStyle = 'red'
                    ctx.fillRect(x+7+i, y+60+(Math.random()*15+1), 5, 5)
                    ctx.clearRect(x+7+i, y+60+(Math.random()*15+1), 5, 5)
                }
            }
            ctx.restore()

            // mark the destination spot
            ctx.fillStyle = "red";
            ctx.fillRect(500, 750, 100, 10);

            // check these only when the game is running
            if (props.fields.ready) {
                // check if the player has successfully guided the rocket to the destination
                let win = checkVictory();
                // check if the player has gone off the map or crashed
                if (!win) checkBoundaries();
            }
        }

        // get the logics to be drawn on the canvas
        Logic();

        // setting the canvas size
        const {width, height} = canvas.getBoundingClientRect();
        if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
        }
    }, [])

    return <canvas className="canvas" ref={canvasRef} style={{width: 915, height: 955, zIndex: 1, border: `1px solid white`}} {...props}/>
}


export default Canvas;