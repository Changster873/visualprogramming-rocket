import React, {useRef, useEffect} from 'react';

const Canvas = props => {
    
    const canvasRef = useRef(null)

    // to run the blocks
    let index = 0; // index for current command being executed
    let time = 0; // duration of each action executed
    let angleChange = -1000; // used to help angle turn slowly to user inpput value in the useEffect cycle without using useRef hook
    let currentAction;

    // properties of the rocket
    let x = 100 // inital x position of the rocket
    let y = 700 // initial y position of the rocket
    let yspeed = 100; // moving y speed of the rocket
    let xspeed = 100; // moving x speed of the rocket
    let fuel = 100; // fuel of the rocket
    let wind = 0; // wind of this level
    let angle = 0; // angle of the rocket, 0 is upwards
    let gravity = 0; // gravity (external force pulling on the rocket)

    useEffect(() => {

        // getting the canvas
        const canvas = canvasRef.current
        const ctx = canvas.getContext('2d')

        const Logic = () => {
            // branch off to do whatever from here, read instructions generated by blockly 
            // (e.g. turnRight, so call method update with turnRight if statement branch executed, etc...)

            setTimeout(()=> {
                // set the conditions for the level
                if (props.fields.level === 1) {
                    wind = gravity = 0;
                }
                else if (props.fields.level === 2) {
                    wind = 0.3; // 30km/h
                    gravity = 0.3528; // 9.18m/s but for km/h
                }
                if (props.fields.commands[index] === undefined && index !== 0){
                    resetRocket('Did not reach destination, try again...')
                    props.fields.ready = false;
                }
                currentAction = props.fields.commands[index]
                // if there is an action, begin executing
                if (index !== props.fields.commands.length) update();
                // draw everything the action has specified
                draw();
                window.requestAnimationFrame(Logic)
                // each action runs for three seconds, once reached, reset and go to next action
                //if (props.fields.ready) console.log(time + ":" +props.fields.commands[index])
                if (time === 200) {
                    time = 0;
                    index++;
                }
                else if (props.fields.ready) {
                    time++;
                }
                
            },10)
        }

        function fuelCost() {
            fuel -= ((yspeed + xspeed)/100) * 0.008;
        }

        function resetRocket(msg) {
            ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
            index = 0;
            time = 0;
            x = 100;
            y = 700;
            angle = 0;
            fuel = 100;
            xspeed = yspeed = 100;
            currentAction = undefined
            window.alert(msg);
        }

        function checkVictory() {

            if (fuel <= 0) {
                fuel = 0;
                resetRocket('Rocket out of fuel, try again...')
                props.fields.ready = false; // stop simulation
                return false;
            }

            // level one
            if (props.fields.level === 1) {
                let touchGround = false;
                if (x >= 500 && x <= 600 && y >= 650) {
                    if (y < 700) y++;
                    if (y >= 700) {
                        y = 700;
                        touchGround = true;
                    }
                }

                if (touchGround) {
                    resetRocket('Stage Complete!!!');
                    props.fields.ready = false; // stop simulation
                    return true;
                }
            }

            // level two
            if (props.fields.level === 2) {
                let touchGround = false;
                if (x >= 700 && x <= 800 && y >= 650) {
                    if (y < 700) y++;
                    if (y >= 700) {
                        y = 700;
                        touchGround = true;
                    }
                }

                if (touchGround) {
                    resetRocket('Stage Complete!!!');
                    props.fields.ready = false; // stop simulation
                    return true;
                }
            }
        }

        function checkBoundaries() {
            // level one
            if (props.fields.level === 1) {
                if (y >= 700) {
                    resetRocket('Your rocket crashed, try again...');
                    props.fields.ready = false; // stop simulation
                }
            }
            // level two
            else if (props.fields.level === 2) {
                if (y >= 700) {
                    resetRocket('Your rocket crashed, try again...');
                    props.fields.ready = false; // stop simulation
                }
                if (x >= 350 && y >= 415 && y <= 700 && x < 600) {
                    resetRocket('Your rocket crashed, try again...');
                    props.fields.ready = false; // stop simulation
                }
            }

            if (y < 0 || y > ctx.canvas.height || x < 0 || x > ctx.canvas.width) {
                resetRocket('Rocket out of bounds! Resetting...');
                props.fields.ready = false; // stop simulation
            }
        }
        
        function update() {
            // if no more commands
            if (index >= props.fields.commands.length) {
                props.fields.ready = false; // turn off simulation
                // if simulation no longer running, reset graphics and states
                if (!props.fields.ready) {
                    resetRocket('Did not reach destination, resetting...');
                }
                return;
            }
            // if player wants to simulate their commands, and list of commands is not empty, do what they say
            if (!props.fields.ready && props.fields.commands.length > 0) return;

            if (props.fields.commands[index].type === "launch") {
                y -= (yspeed/100);
                y += gravity;
                x += wind;
                // cut fuel for this action
                fuelCost();
                console.log('Launching rocket...')
            }

            else if (props.fields.commands[index].type === "descend") {
                x += wind;
                y += ((yspeed/100)+gravity);
                // cut fuel for this action
                fuelCost();
                console.log("Descending rocket...")
            }
            else if (props.fields.commands[index].type === "yspeed") {
                let userInput;
                for (let i=0; i<props.fields.commands.length; i++){
                    if (props.fields.commands[index].childBlocks_[i].type === 'math_number') {
                        // get the value inputted by user
                        userInput = props.fields.commands[index].childBlocks_[i].inputList[0].fieldRow[0].value_;
                        break;
                    }
                }
                yspeed = userInput;
                time = 200 // setting speed, should not have the game waiting for it to complete its action
                console.log('Now set to y speed: ' + yspeed)
            }

            else if (props.fields.commands[index].type === "xspeed") {
                let userInput;
                for (let i=0; i<props.fields.commands.length; i++){
                    if (props.fields.commands[index].childBlocks_[i].type === 'math_number') {
                        // get the value inputted by user
                        userInput = props.fields.commands[index].childBlocks_[i].inputList[0].fieldRow[0].value_;
                        break;
                    }
                }
                xspeed = userInput;
                time = 200 // setting speed, should not have the game waiting for it to complete its action
                console.log('Now set to x speed: ' + xspeed)
            }

            else if (props.fields.commands[index].type === "stall") {
                let initial = 0;
                // if rocket is going right
                if (angle > 0 && angle < 55) {
                    initial = xspeed
                    x += ((xspeed/2)/100);
                    x += wind;
                    xspeed = initial
                    y -= (yspeed/100);
                    y += gravity;
                }
                else if (angle >= 55 && angle <= 90) {
                    x += (xspeed/100);
                    x += wind;
                    if (angle !== 90) {
                        initial = yspeed
                        y -= ((yspeed/2)/100);
                        y += gravity;
                        yspeed = initial
                    }
                }
                else if (angle > 90 && angle < 120) {
                    initial = yspeed
                    x += (xspeed/100);
                    x += wind;
                    y += (((yspeed/2)/100)+gravity);
                    yspeed = initial

                }
                else if (angle >= 120 && angle < 180) {
                    initial = xspeed
                    x += ((xspeed/2)/100);
                    x += wind;
                    xspeed = initial
                    y += ((yspeed/100)+gravity);
                }

                // if rocket is going left
                if (angle < 0 && angle > -55) {
                    initial = xspeed
                    x -= ((xspeed/2)/100);
                    x += wind;
                    y -= (yspeed/100);
                    y += gravity;
                    xspeed = initial
                }
                else if (angle <= -55 && angle >= -90) {
                    x -= (xspeed/100);
                    x += wind;
                    if (angle !== -90) {
                        initial = yspeed
                        y -= (((yspeed/2)/100));
                        y += gravity;
                        yspeed = initial
                    }
                }
                else if (angle < -90 && angle > -120) {
                    initial = yspeed
                    x -= (xspeed/100);
                    x += wind;
                    y += (((yspeed/2)/100)+gravity);
                    yspeed = initial
                }
                else if (angle <= -120 && angle > 180) {
                    initial = xspeed
                    x -= ((xspeed/2)/100);
                    x += wind;
                    y += ((yspeed/100)+gravity);
                    xspeed = initial
                }
                
                // if rocket just points straight upwards
                else if (angle === 0){
                    y -= (yspeed/100);
                    y += gravity;
                    x += wind;
                }

                // cut fuel of this action
                fuelCost();

                console.log('Going in the same direction for this turn')
            }

            else if (props.fields.commands[index].type === "right") {
                let userInput;
                for (let i=0; i<props.fields.commands.length; i++){
                    if (props.fields.commands[index].childBlocks_[i].type === 'math_number') {
                        // get the value inputted by user
                        userInput = props.fields.commands[index].childBlocks_[i].inputList[0].fieldRow[0].value_;
                        break;
                    }
                }
                let newA = userInput + angle;
                if (angleChange === -1000) {
                    angleChange = newA;
                }
                newA = angleChange;
                if (angle !== angleChange) {
                    angle++;
                }
                else if (angle === angleChange) {
                    angleChange = -1000;
                    time = 200;
                }
                
                // cut fuel for this action
                fuelCost();
                console.log('Turning right');
            }

            else if (props.fields.commands[index].type === "left") {
                let userInput;
                for (let i=0; i<props.fields.commands.length; i++){
                    if (props.fields.commands[index].childBlocks_.length === 0) {
                        continue;
                    }
                    if (props.fields.commands[index].childBlocks_[i].type === 'math_number') {
                        // get the value inputted by user
                        userInput = props.fields.commands[index].childBlocks_[i].inputList[0].fieldRow[0].value_;
                        break;
                    }
                }
                let newA = (-1 * (userInput)) + angle;
                if (angleChange === -1000) {
                    angleChange = newA;
                }
                newA = angleChange;
                if (angle !== angleChange) {
                    angle--;
                }
                else if (angle === angleChange) {
                    angleChange = -1000;
                    time = 200;
                } 
                
                // cut fuel for this action
                fuelCost();
                console.log('Turning left')
            }
        }
        
        function draw() {
            // clear the canvas before drawing new frame
            ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);

            // draw measurements for players to refer to
            ctx.fillStyle = 'purple'
            for (let i=0; i<955; i+=200) {
                ctx.fillRect(0, i, 10, 195)
                ctx.fillStyle = 'white'
                ctx.fillRect(0, i+95, 10, 5)
                ctx.fillStyle = 'purple'
            }
            for (let i=0; i<915; i+=200) {
                ctx.fillRect(i, 0, 195, 10)
                ctx.fillStyle = 'white'
                ctx.fillRect(i+95, 0, 5, 10)
                ctx.fillStyle = 'purple'
            }

            // have the rocket status displayed
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText('Angle: ' + angle, 10, 25);

            ctx.fillText('X Speed: ' + xspeed + 'km/h', 10 , 55)
            ctx.fillText('Y Speed: ' + yspeed + 'km/h', 10 , 85)

            ctx.fillRect(237, 5, 100, 25)
            ctx.fillText('Fuel: ' + Math.floor(fuel), 150, 25);
            if (fuel >= 0 && fuel < 35) {
                ctx.fillStyle = 'red'
            }
            else if (fuel >= 35 && fuel < 65) {
                ctx.fillStyle = 'yellow'
            }
            else if (fuel >= 65 && fuel < 85) {
                ctx.fillStyle = 'orange'
            }
            else {
                ctx.fillStyle = 'green'
            }
            ctx.fillRect(237, 5, fuel, 25);

            // have the level conditions displayed
            ctx.fillStyle = 'white'
            ctx.fillText('Wind: ' + wind*100, 820, 25);
            ctx.fillText('Gravity: ' + gravity*100, 680, 25);
            ctx.fillText('Level: ' + props.fields.level, 580, 25)

            // display the current action
            ctx.fillText('Current action: ' , 400, 25)
            ctx.fillText((currentAction ? currentAction : 'None'), 400, 55)
            
            if (props.fields.level === 1) {
                // draw the ground
                let img2 = document.getElementById('grass')
                let img3 = document.getElementById('ground')
                for (let i=0;i<915; i+=10) {
                    ctx.drawImage(img2, i, 745, 20, 20)
                    for (let j=765; j<955; j+=10) {
                        ctx.drawImage(img3, i, j, 20, 20)
                    }
                }

                // mark the destination spot
                ctx.fillStyle = "red";
                ctx.fillRect(500, 750, 100, 10);
            }

            if (props.fields.level === 2) {
                // draw the ground
                let img2 = document.getElementById('grass')
                let img3 = document.getElementById('ground')
                for (let i=0;i<400; i+=10) {
                    ctx.drawImage(img2, i, 745, 20, 20)
                    for (let j=765; j<955; j+=10) {
                        ctx.drawImage(img3, i, j, 20, 20)
                    }
                }

                for (let i=400;i<599; i+=10) {
                    ctx.drawImage(img2, i, 445, 20, 20)
                    for (let j=465; j<955; j+=10) {
                        ctx.drawImage(img3, i, j, 20, 20)
                    }
                }

                for (let i=600;i<915; i+=10) {
                    ctx.drawImage(img2, i, 745, 20, 20)
                    for (let j=765; j<955; j+=10) {
                        ctx.drawImage(img3, i, j, 20, 20)
                    }
                }

                // mark the destination spot
                ctx.fillStyle = "red";
                ctx.fillRect(700, 750, 100, 10);
            }
            
            
            // draw the rocket
            ctx.fillStyle = '#ff8080';
            ctx.save()
            ctx.translate(x+30/2,y+50/2)
            ctx.rotate(angle*Math.PI/180)
            ctx.translate(-(x+30/2),-(y+50/2))
            let img = document.getElementById('rocket')
            ctx.drawImage(img, x, y,30,50)

            // draw the rocket's engine flames
            if (props.fields.ready) {
                for (let i=0; i<20; i+=1) {
                    ctx.fillStyle = 'red'
                    ctx.fillRect(x+3+i, y+50+(Math.random()*15+1), 5, 5)
                    ctx.clearRect(x+3+i, y+50+(Math.random()*15+1), 5, 5)
                }
                for (let i=0; i<10; i+=1) {
                    ctx.fillStyle = 'red'
                    ctx.fillRect(x+7+i, y+60+(Math.random()*15+1), 5, 5)
                    ctx.clearRect(x+7+i, y+60+(Math.random()*15+1), 5, 5)
                }
            }
            ctx.restore()

            // check these only when the game is running
            if (props.fields.ready) {
                // check if the player has successfully guided the rocket to the destination
                let win = checkVictory();
                // check if the player has gone off the map or crashed
                if (!win) checkBoundaries();
            }
        }

        // get the logics to be drawn on the canvas
        Logic();

        // setting the canvas size
        const {width, height} = canvas.getBoundingClientRect();
        if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
        }
    }, [])

    return <canvas className="canvas" ref={canvasRef} style={{width: 915, height: 955, zIndex: 1, border: `1px solid white`}} {...props}/>
}


export default Canvas;